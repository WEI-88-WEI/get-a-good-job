<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // 同渡一667
      var spiralOrder = function (matrix) {
        // 方法一：暴力法（循环模拟）---时间：O（nm）（）---空间：O（nm）（）
        // const row = matrix.length;
        // const col = matrix[0].length;
        // const arr = Array.from({ length: row }, () => new Array(col).fill(0));
        // const result = [];
        // const flatArr = arr.flat()
        // let i = 0;
        // let j = 0;
        // let stepi = 0;
        // let stepj = 1;
        // let count = 0;
        // while (1) {
        //   arr[i][j] = result[count++];
        //   result.push(matrix[i][j]);
        //   i += stepi;
        //   j += stepj;
        //   if (hasBlock(arr, i, j)) {
        //     // 掉头
        //     i -= stepi;
        //     j -= stepj;
        //     if (stepi === 0) {
        //       stepi = stepj;
        //       stepj = 0;
        //     } else {
        //       stepj = -stepi;
        //       stepi = 0;
        //     }
        //     i += stepi;
        //     j += stepj;
        //   }
        //   if (hasBlock(arr, i, j)) break;
        // }
        // return result;

        // function hasBlock(arr, i, j) {
        //   return !arr[i] || arr[i][j] !== 0;
        // }

        // 方法二：暴力法（循环模拟）---时间：O（nm）（）---空间：O（nm）（官方说是1，不算结果数组空间）
        // let l = 0
        // let u = 0
        // let r = matrix[0].length - 1
        // let d = matrix.length - 1
        // let result = []
        // while(1){
        //   // 向右
        //   for(let i = l; i <= r; i++){
        //     result.push(matrix[u][i])
        //   }
        //   if (++u > d) break;
        //   // 向下
        //   for(let i = u; i <= d; i++){
        //     result.push(matrix[i][r])
        //   }
        //   if (--r < l) break;
        //   // 向左
        //   for(let i = r; i >= l; i--){
        //     result.push(matrix[d][i])
        //   }
        //   if (--d < u) break;
        //   // 向上
        //   for(let i = d; i >= u; i--){
        //     result.push(matrix[i][l])
        //   }
        //   if (++l > r) break;
        // }
        // return result

        // 方法三：暴力法（按层模拟）---时间：O（nm）（）---空间：O（nm）（官方说是1，不算结果数组空间）
        let result = [];
        let l = 0;
        let r = matrix[0].length - 1;
        let u = 0;
        let b = matrix.length - 1;
        while (l < r && u < b) {
          // 向右
          for (let i = l; i <= r; i++) {
            result.push(matrix[u][i]);
          }
          // 向下
          for (let i = u + 1; i <= b; i++) {
            result.push(matrix[i][r]);
          }
          // 向左
          for (let i = r - 1; i >= l; i--) {
            result.push(matrix[b][i]);
          }
          // 向上
          for (let i = b - 1; i >= u + 1; i--) {
            result.push(matrix[i][l]);
          }
          l++, r--, u++, b--;
        }
        // 剩下一行，从左到右依次添加
        if(u===b){
          for(let i = l; i <= r; i++){
            result.push(matrix[u][i]);
          }
        }
        // 剩下一列，从上到下依次添加
        else if(l===r){
          for(let i = u; i <= b; i++){
            result.push(matrix[i][l]);
          }
        }
        return result;
      };
      // console.log(
      //   spiralOrder([
      //     [1, 2, 3],
      //     [4, 5, 6],
      //     [7, 8, 9],
      //   ])
      // );
      console.log(
        spiralOrder([
          [1, 2, 3, 4],
          [5, 6, 7, 8],
          [9, 10, 11, 12],
        ])
      );
    </script>
  </body>
</html>
