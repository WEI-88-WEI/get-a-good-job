<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <script>
    var preorderTraversal = function (root) {
      // 方法一：递归---时间O（n）（）---空间：O（n）（）
      // const stack = []
      // function preOrder(root) {
      //   if (!root) return
      //   stack.push(root.val)
      //   preOrder(root.left)
      //   preOrder(root.right)
      // }
      // preOrder(root)
      // return stack

      // 方法一：遍历---时间O（n）（）---空间：O（n）（）
      // let stack = [root]
      // let res = []
      // if (!root) return res
      // while (stack.length) {
      //   // 这里存在一个问题，为什么我用shift()，然后先左后右还是不行
      //   // 错(假设左子节点开始遍历)：取[右，左，右]进
      //   // 对(假设左子节点开始遍历)：[右，右，左]进/取---这样才能读取了左边之后继续读左边
      //   let a = stack.pop()
      //   res.push(a.val)
      //   // 结合栈后进先出的特点，所以左节点要后入栈，右节点要先入栈
      //   a.right && stack.push(a.right)
      //   a.left && stack.push(a.left)
      // }
      // return res

      // 方法一：遍历---时间O（n）（）---空间：O（n）（）
      const stack = []
      const res = []
      let prev = null
      while (root || stack.length) {
        debugger;
        while (root) {
          stack.push(root)
          root = root.left
        }
        root = stack.pop()
        // prev记录上一个有左右子节点的节点，当他第一次pop()的时候
        // 会再push到stack里面去，之后root = root.right，先去算right，并且用prev记录这个节点的right
        // 下次再把这个节点拿出来的时候root.right === prev就可以输出这个节点的值了
        if (root.right === null || root.right === prev) {
          res.push(root.val)
          prev = root
          root = null
        }else{
          stack.push(root)
          root = root.right
        }
      }
      return res
    };
  </script>
</body>

</html>